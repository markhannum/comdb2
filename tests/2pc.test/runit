#!/usr/bin/env bash
bash -n "$0" | exit 1

. ${TESTSROOTDIR}/tools/cluster_utils.sh
. ${TESTSROOTDIR}/tools/runit_common.sh
. ${TESTSROOTDIR}/tools/hrtime.sh

export maxtime=30000
export debug=1
#export DEBUGTRACE="--debugtrace"
export DEBUGTRACE=""

[[ $debug == "1" ]] && set -x

export comdb2db_hosts="${SENARY_DBNAME}:1234"
export COMDB2DB_DBNAME=${SENARY_DBNAME}
export COMDB2DB_OPTIONS=${SENARY_CDB2_OPTIONS}
export LOGDIR=$TESTDIR/logs

function stop_all_databases
{
    for node in $CLUSTER ; do
         kill -9 $(cat ${TMPDIR}/${DBNAME}.${node}.pid)
         kill -9 $(cat ${TMPDIR}/${SECONDARY_DBNAME}.${node}.pid)
         kill -9 $(cat ${TMPDIR}/${TERTIARY_DBNAME}.${node}.pid)
         kill -9 $(cat ${TMPDIR}/${QUATERNARY_DBNAME}.${node}.pid)
         kill -9 $(cat ${TMPDIR}/${QUINARY_DBNAME}.${node}.pid)
         kill -9 $(cat ${TMPDIR}/${SENARY_DBNAME}.${node}.pid)
    done
}

function fail_exit()
{
    echo "Failed $@" | tee ${DBNAME}.failexit # runtestcase script looks for this file
    stop_all_databases
    exit -1
}

function update_all_tunables
{
    # Update tunables
    if [[ -z ${CLUSTER} ]]; then
        $CDB2SQL_EXE -admin $CDB2_OPTIONS $DBNAME default "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
        $CDB2SQL_EXE -admin $CDB2_OPTIONS $DBNAME default "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

        $CDB2SQL_EXE -admin $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
        $CDB2SQL_EXE -admin $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

        $CDB2SQL_EXE -admin $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
        $CDB2SQL_EXE -admin $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

        $CDB2SQL_EXE -admin $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
        $CDB2SQL_EXE -admin $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

        $CDB2SQL_EXE -admin $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
        $CDB2SQL_EXE -admin $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1
    else
        for mach in ${CLUSTER}; do
            $CDB2SQL_EXE -admin $CDB2_OPTIONS $DBNAME --host $mach "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
            $CDB2SQL_EXE -admin $CDB2_OPTIONS $DBNAME --host $mach "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

            $CDB2SQL_EXE -admin $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $mach "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
            $CDB2SQL_EXE -admin $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $mach "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

            $CDB2SQL_EXE -admin $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $mach "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
            $CDB2SQL_EXE -admin $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $mach "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

            $CDB2SQL_EXE -admin $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME --host $mach "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
            $CDB2SQL_EXE -admin $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME --host $mach "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

            $CDB2SQL_EXE -admin $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME --host $mach "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
            $CDB2SQL_EXE -admin $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME --host $mach "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1
        done
    fi
}

# Setup comdb2db tables- modeled from incoh_remsql test
function create_comdb2db
{
    # Create comdb2db tables
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "create table if not exists clusters {`cat clusters.csc2`}" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "create table if not exists machines {`cat machines.csc2`}" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "create table if not exists databases {`cat databases.csc2`}" >/dev/null 2>&1

    # Populate databases
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into databases(name, dbnum) values('${DBNAME}', 1234) on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into databases(name, dbnum) values('${SECONDARY_DBNAME}', 1235) on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into databases(name, dbnum) values('${TERTIARY_DBNAME}', 1236) on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into databases(name, dbnum) values('${QUATERNARY_DBNAME}', 1237) on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into databases(name, dbnum) values('${QUINARY_DBNAME}', 1237) on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into databases(name, dbnum) values('${SENARY_DBNAME}', 1238) on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into databases(name, dbnum) values('${COMDB2DB_DBNAME}', 1239) on conflict do nothing" >/dev/null 2>&1

    # Populate clusters
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into clusters(name, cluster_name, cluster_machs) values('${DBNAME}', 'prod', 'KABOOM') on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into clusters(name, cluster_name, cluster_machs) values('${SECONDARY_DBNAME}', 'prod', 'KABOOM') on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into clusters(name, cluster_name, cluster_machs) values('${TERTIARY_DBNAME}', 'prod', 'KABOOM') on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into clusters(name, cluster_name, cluster_machs) values('${QUATERNARY_DBNAME}', 'prod', 'KABOOM') on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into clusters(name, cluster_name, cluster_machs) values('${QUINARY_DBNAME}', 'prod', 'KABOOM') on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into clusters(name, cluster_name, cluster_machs) values('${SENARY_DBNAME}', 'prod', 'KABOOM') on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into clusters(name, cluster_name, cluster_machs) values('${COMDB2DB_DBNAME}', 'prod', 'KABOOM') on conflict do nothing" >/dev/null 2>&1

    # Populate machines
    if [[ -z ${CLUSTER} ]]; then
        $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into machines(name, cluster, room) values ('localhost', 'KABOOM', 'NY') on conflict do nothing" >/dev/null 2>&1
        comdb2db_hosts="${comdb2db_hosts}:localhost"
    else
        let nnodes=0
        for mach in ${CLUSTER} ; do
            $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into machines(name, cluster, room) values('${mach}', 'KABOOM', 'NY') on conflict do nothing" >/dev/null 2>&1
            comdb2db_hosts="${comdb2db_hosts}:${mach}"
            let nnodes=nnodes+1
        done
    fi

    echo "Refreshing all tunables"
    update_all_tunables
}

function find_master
{
    $CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default 'select host from comdb2_cluster where is_master="Y"'
}

function find_secondary_master
{
    $CDB2SQL_EXE --tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default 'select host from comdb2_cluster where is_master="Y"'
}

function find_tertiary_master
{
    $CDB2SQL_EXE --tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default 'select host from comdb2_cluster where is_master="Y"'
}

function create_tables
{
    # Create t1
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create table t1(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || failexit "failed creating table t1 for $DBNAME $x"
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create unique index t1a on t1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || failexit "failed creating unique index for $DBNAME $x"

    x=$($CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "create table t1(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || failexit "failed creating table t1 for $SECONDARY_DBNAME $x"
    x=$($CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "create unique index t1a on t1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || failexit "failed creating unique index for $SECONDARY_DBNAME $x"

    x=$($CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "create table t1(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || failexit "failed creating table t1 for $TERTIARY_DBNAME $x"
    x=$($CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "create unique index t1a on t1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || failexit "failed creating index for $TERTIARY_DBNAME $x"


    x=$($CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "create table t1(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || failexit "failed creating table t1 for $QUATERNARY_DBNAME $x"
    x=$($CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "create unique index t1a on t1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || failexit "failed creating index for $QUATERNARY_DBNAME $x"

    x=$($CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "create table t1(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || failexit "failed creating table t1 for $QUINARY_DBNAME $x"
    x=$($CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "create unique index t1a on t1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || failexit "failed creating index for $QUINARY_DBNAME $x"
}

function delete_records_ignore_error
{
    echo "delete_records_ignore_error"
    typeset r=1
    typeset j=0
    while [[ "$r" -ne "0" ]]; do
    let j=j+1
    echo "begin
delete from t1 where 1
delete from $SECONDARY_DBNAME.t1 where 1
delete from $TERTIARY_DBNAME.t1 where 1
delete from $QUATERNARY_DBNAME.t1 where 1
delete from $QUINARY_DBNAME.t1 where 1
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    r=$?
    
    if [[ "$r" -ne "0" ]] ; then
        echo "Error deleting iteration $j"
        update_all_tunables
        sleep 1
    fi
    done
}

function delete_records
{
    echo "delete_records"
    typeset j=0
    echo "begin
delete from t1 where 1
delete from $SECONDARY_DBNAME.t1 where 1
delete from $TERTIARY_DBNAME.t1 where 1
delete from $QUATERNARY_DBNAME.t1 where 1
delete from $QUINARY_DBNAME.t1 where 1
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
    r=$?
    [[ "$r" == "0" ]] || fail_exit "failed deleting records"

    # Verify that they are deleted
    echo "Sleeping for 3"
    sleep 3

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    if [[ "$x" -ne "0" ]]; then
        fail_exit "$DBNAME has $x records after delete"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $SECONDARY_DBNAME.t1")
    if [[ "$x" -ne "0" ]]; then
        fail_exit "$SECONDARY_DBNAME has $x records after delete"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $TERTIARY_DBNAME.t1")
    if [[ "$x" -ne "0" ]]; then
        fail_exit "$TERTIARY_DBNAME has $x records after delete"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $QUATERNARY_DBNAME.t1")
    if [[ "$x" -ne "0" ]]; then
        fail_exit "$QUATERNARY_DBNAME has $x records after delete"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $QUINARY_DBNAME.t1")
    if [[ "$x" -ne "0" ]]; then
        fail_exit "$QUINARY_DBNAME has $x records after delete"
    fi
}

function insert_records_bulk
{
    echo "insert_records_bulk"
    typeset j=0
    typeset count=$1
    typeset iterations=$2
    while [[ $j -lt $iterations ]]; do
        echo "begin
insert into t1(a) select * from generate_series($(( ( j * count ) + 1)), $(( ( j + 1 ) * count )))
insert into $SECONDARY_DBNAME.t1(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
insert into $TERTIARY_DBNAME.t1(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
insert into $QUATERNARY_DBNAME.t1(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
insert into $QUINARY_DBNAME.t1(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
        r=$?
        [[ "$r" == "0" ]] || fail_exit "failed inserting iteration $j"
        let j=j+1
    done
}

function insert_records_to_normalize
{
    echo "insert_records_to_normalize"
    j=0
    startms=$(timems)
    while [[ $j -lt 10 ]]; do
        echo "begin
insert into t1(a) values($j)
insert into $SECONDARY_DBNAME.t1(a) values($j)
insert into $TERTIARY_DBNAME.t1(a) values($j)
insert into $QUATERNARY_DBNAME.t1(a) values($j)
insert into $QUINARY_DBNAME.t1(a) values($j)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
        r=$?
        [[ "$r" == "0" ]] || fail_exit "failed inserting iteration $j"
        let j=j+1
    done

    # Verify that there are 10 records in each database
    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    [[ "$x" != "10" ]] && fail_exit "$DBNAME has only $x records"

    x=$($CDB2SQL_EXE -tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "10" ]] && fail_exit "$SECONDARY_DBNAME has only $x records"

    x=$($CDB2SQL_EXE -tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "10" ]] && fail_exit "$TERTIARY_DBNAME has only $x records"

    x=$($CDB2SQL_EXE -tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "10" ]] && fail_exit "$QUATERNARY_DBNAME has only $x records"

    x=$($CDB2SQL_EXE -tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "10" ]] && fail_exit "$QUINARY_DBNAME has only $x records"

    delete_records
}

function insert_records_basic
{
    echo "insert_records_basic"
    j=0
    startms=$(timems)
    while [[ $j -lt 1000 ]]; do
        startsinglems=$(timems)
        echo "begin
insert into t1(a) values($j)
insert into $SECONDARY_DBNAME.t1(a) values($j)
insert into $TERTIARY_DBNAME.t1(a) values($j)
insert into $QUATERNARY_DBNAME.t1(a) values($j)
insert into $QUINARY_DBNAME.t1(a) values($j)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
        r=$?
        stopsinglems=$(timems)
        [[ "$r" == "0" ]] || fail_exit "failed inserting iteration $j"
        if [[ "$(( stopsinglems - startsinglems ))" -gt $maxtime ]]; then
            #fail_exit "Single record test took $(( stopsinglems - startsinglems )) ms"
            while :; do
                echo "test failed, single record took $(( stopsinglems - startsinglems )) ms"
                sleep 1
            done
        fi
        let j=j+1
    done
    donems=$(timems)
    elapsed=$(( donems - startms ))
    echo "Elapsed time is $elapsed"

    # Verify counts
    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    #[[ "$x" == "1000" ]] || fail_exit "$DBNAME has only $x records"
    if [[ "$x" != "1000" ]] ; then 
        for node in $CLUSTER ; do
            echo "Node $node"
            x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME --host $node "select count(*) from t1")
            x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME --host $node "select * from t1")
        done
        fail_exit "$DBNAME has only $x records"
    fi 

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $SECONDARY_DBNAME.t1")
    if [[ "$x" != "1000" ]] ; then 
        for node in $CLUSTER ; do
            echo "Node $node"
            x=$($CDB2SQL_EXE -tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $node "select count(*) from t1")
            x=$($CDB2SQL_EXE -tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $node "select * from t1")
        done
        fail_exit "$SECONDARY_DBNAME has only $x records"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $TERTIARY_DBNAME.t1")
    if [[ "$x" != "1000" ]] ; then 
        for node in $CLUSTER ; do
            echo "Node $node"
            x=$($CDB2SQL_EXE -tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $node "select count(*) from t1")
            x=$($CDB2SQL_EXE -tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $node "select * from t1")
        done
        fail_exit "$TERTIARY_DBNAME has only $x records"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $QUATERNARY_DBNAME.t1")
    if [[ "$x" != "1000" ]] ; then 
        for node in $CLUSTER ; do
            echo "Node $node"
            x=$($CDB2SQL_EXE -tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME --host $node "select count(*) from t1")
            x=$($CDB2SQL_EXE -tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME --host $node "select * from t1")
        done
        fail_exit "$QUATERNARY_DBNAME has only $x records"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $QUINARY_DBNAME.t1")
    if [[ "$x" != "1000" ]] ; then 
        for node in $CLUSTER ; do
            echo "Node $node"
            x=$($CDB2SQL_EXE -tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME --host $node "select count(*) from t1")
            x=$($CDB2SQL_EXE -tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME --host $node "select * from t1")
        done
        fail_exit "$QUINARY_DBNAME has only $x records"
    fi
}

function setup
{
    create_comdb2db
    create_tables
}

function basic_test
{
    typeset j=0
    typeset cnt=${1:-3}
    while [[ $j -lt $cnt ]]; do
        insert_records_basic
        delete_records
        let j=j+1
    done
}

function bulk_test
{
    typeset cnt=${1:-3}
    typeset j=0
    while [[ $j -lt "$cnt" ]]; do
        insert_records_bulk 2000 50
        delete_records
        let j=j+1
    done
}

function participant_constraint_violation
{
    typeset j=0
    typeset r=0
    while [[ $j -lt 1000 ]]; do
    echo "begin
insert into t1(a) values($j)
insert into $SECONDARY_DBNAME.t1(a) values($j)
insert into $TERTIARY_DBNAME.t1(a) values($j)
insert into $QUATERNARY_DBNAME.t1(a) values($j)
insert into $QUINARY_DBNAME.t1(a) values($j)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -

    r=$?
    [[ "$r" == "0" ]] || failexit "participant_constraint_violation failed inserting"

    # Try each case in turn
    if [[ "$(( j % 4 ))" == "0" ]]; then
    echo "begin
insert into t1(a) values($(( j + 1 )))
insert into $SECONDARY_DBNAME.t1(a) values($j)
insert into $TERTIARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUATERNARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUINARY_DBNAME.t1(a) values($(( j + 1 )))
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    r=$?
    fi

    if [[ "$(( j % 4 ))" == "1" ]]; then
    echo "begin
insert into t1(a) values($(( j + 1 )))
insert into $SECONDARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $TERTIARY_DBNAME.t1(a) values($j)
insert into $QUATERNARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUINARY_DBNAME.t1(a) values($(( j + 1 )))
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    r=$?
    fi

    if [[ "$(( j % 4 ))" == "2" ]]; then
    echo "begin
insert into t1(a) values($(( j + 1 )))
insert into $SECONDARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $TERTIARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUATERNARY_DBNAME.t1(a) values($j)
insert into $QUINARY_DBNAME.t1(a) values($(( j + 1 )))
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    r=$?
    fi

    if [[ "$(( j % 4 ))" == "3" ]]; then
    echo "begin
insert into t1(a) values($(( j + 1 )))
insert into $SECONDARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $TERTIARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUATERNARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUINARY_DBNAME.t1(a) values($j)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    r=$?
    fi

    [[ "$r" != "0" ]] || failexit "participant_constraint_violation succeeded incorrectly"
    
    let j=j+1
    done

    delete_records
}

function coordinator_constraint_violation
{
    typeset j=0
    while [[ $j -lt 1000 ]]; do
    startms=$(timems)
    echo "begin
insert into t1(a) values($j)
insert into $SECONDARY_DBNAME.t1(a) values($j)
insert into $TERTIARY_DBNAME.t1(a) values($j)
insert into $QUATERNARY_DBNAME.t1(a) values($j)
insert into $QUINARY_DBNAME.t1(a) values($j)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?

    donems=$(timems)

    [[ "$r" == "0" ]] || failexit "coordonator_constraint+violation failed inserting, r=$r"

    if [[ "$(( donems - startms ))" -gt $maxtime ]]; then
        failexit "coordinator took excessive time to insert good record"
    fi

    startms=$(timems)
    echo "begin
insert into $SECONDARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $TERTIARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUATERNARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUINARY_DBNAME.t1(a) values($(( j + 1 )))
insert into t1(a) values(${j})
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?

    donems=$(timems)

    [[ "$r" != "0" ]] || failexit "coordinator_constraint_violation succeeded incorrectly rcode=$r"
    
    if [[ "$(( donems - startms ))" -gt $maxtime ]]; then
        failexit "coordinator took excessive time to fail to insert insert bad record"
    fi

    let j=j+1
    done

    delete_records
}

function kill_restart_cluster
{
    typeset dbname=$1
    typeset options=$2
    typeset dbdir=$3
    typeset sleeptime=$4

    # Add 2 second of latency to respond to a prepare
    sleep 2

    REP_ENV_VARS="${dbdir}/replicant_env_vars"
    for node in $CLUSTER ; do
        $CDB2SQL_EXE $options $dbname --host $node "exec procedure sys.cmd.send('flush')"
        PARAMS="$dbname --no-global-lrl"
        CMD="sleep $sleeptime ; source ${REP_ENV_VARS} ; ${COMDB2_EXE} ${PARAMS} --lrl $dbdir/${dbname}.lrl --pidfile ${TMPDIR}/${dbname}.pid"
        if [ $node == $(hostname) ] ; then

            (
                kill -9 $(cat ${TMPDIR}/${dbname}.${node}.pid)
                mv --backup=numbered $LOGDIR/${dbname}.db $LOGDIR/${dbname}.db.1
                sleep $sleeptime
                ${DEBUG_PREFIX} ${COMDB2_EXE} ${PARAMS} --lrl $dbdir/${dbname}.lrl --pidfile ${TMPDIR}/${dbname}.${node}.pid 2>&1 | gawk '{ print strftime("%H:%M:%S>"), $0; fflush(); }' >$TESTDIR/logs/${dbname}.${node}.db 2>&1
            ) &

        else

            kill -9 $(cat ${TMPDIR}/${dbname}.${node}.pid)
            mv --backup=numbered $LOGDIR/${dbname}.${node}.db $LOGDIR/${dbname}.${node}.db.1
            sleep $sleeptime
            ssh -o StrictHostKeyChecking=no -tt $node ${DEBUG_PREFIX} ${CMD} 2>&1 </dev/null > >(gawk '{ print strftime("%H:%M:%S>"), $0; fflush(); }' >> $TESTDIR/logs/${dbname}.${node}.db) &
            echo $! > ${TMPDIR}/${dbname}.${node}.pid

        fi
    done

}

function block_until_cluster_is_up
{
    typeset dbname=$1
    typeset options=$2
    typeset isup=0

    while [[ "$isup" == 0 ]]; do
        isup=1
        for node in ${CLUSTER}; do
            $CDB2SQL_EXE $options $dbname --host $node "select 1"
            if [[ $? != 0 ]]; then
                isup=0
            fi
        done
        [[ "$isup" == 0 ]] && sleep 1
    done
}

# Setting the linger-time to 0 to force coordinator to search dist-txn table 
# to resolve participant's prepared txn
function exit_participant_after_prepare_from_table
{
    echo "exit_participant_after_prepare_from_table"
    typeset failed=0
    typeset master=$(find_tertiary_master)
    typeset coordinator_master=$(find_master)
    $CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $master "put tunable debug_exit_participant_after_prepare '1'"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $coordinator_master "put tunable disttxn_linger '0'"

    startms=$(timems)

    echo "Killing and restarting $TERTIARY_DBNAME in the background"
    kill_restart_cluster $TERTIARY_DBNAME "$TERTIARY_CDB2_OPTIONS" $TERTIARY_DBDIR 5 &
    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    endms=$(timems)

    if [[ "$r" != "0" ]] ; then 
        echo "Participant did not recover transaction rcode=$r"
        failed=1
    fi

    echo "sleeping for 60 seconds for cluster to restart and for orphaned prepare to resolve"
    sleep 60

    echo "Reset linger-time to 10 seconds"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $coordinator_master "put tunable disttxn_linger '10'"

    echo "Find $TERTIARY_DBNAME master"

    master=""
    while [[ -z "$master" ]]; do
        sleep 1
        master=$(find_tertiary_master)
    done

    echo "Update all tunables"
    update_all_tunables

    echo "Verify record is there"

    x=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $DBNAME"

    x=$($CDB2SQL_EXE --tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $SECONDARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $master "select * from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $TERTIARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $QUATERNARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $QUINARY_DBNAME"

    [[ "$failed" != 0 ]] && failexit "Bad rcode $r from original transaction"

    delete_records
}

function exit_participant_after_prepare
{
    echo "exit_participant_after_prepare"
    typeset master=$(find_secondary_master)
    $CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $master "put tunable debug_exit_participant_after_prepare '1'"

    startms=$(timems)
    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    endms=$(timems)

    if [[ "$r" != "0" ]] ; then 
        #stop_all_databases
        echo "participant did not recover transaction rcode=$r"
    fi

    echo "verify we can contact secondary db"
    r=1
    while [[ "$r" -ne "0" ]]; do
        $CDB2SQL_EXE --tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select 1"
        r=$?
        [[ "$r" -ne 0 ]] && sleep 1
    done

    echo "sleeping for 10 seconds for sanity"
    sleep 10

    echo "Verify record is there"

    x=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $DBNAME"

    x=$($CDB2SQL_EXE --tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $SECONDARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $TERTIARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $QUATERNARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $QUINARY_DBNAME"

    echo "Restart $SECONDARY_DBNAME on $master"
    pushd $SECONDARY_DBDIR
    export LOGDIR=$TESTDIR/logs
    if [ $master == `hostname` ] ; then
        PARAMS="--no-global-lrl --lrl $SECONDARY_DBDIR/${SECONDARY_DBNAME}.lrl --pidfile ${TMPDIR}/${SECONDARY_DBNAME}.${master}.pid"
        $COMDB2_EXE ${SECONDARY_DBNAME} ${PARAMS} &> $LOGDIR/${SECONDARY_DBNAME}.${master}.db.1 &
    else
        PARAMS="--no-global-lrl --lrl $SECONDARY_DBDIR/${SECONDARY_DBNAME}.lrl --pidfile ${TMPDIR}/${SECONDARY_DBNAME}.${master}.pid"
        CMD="cd ${SECONDARY_DBDIR}; source ${REP_ENV_VARS} ; $COMDB2_EXE ${SECONDARY_DBNAME} ${PARAMS} 2>&1 | tee $TESTDIR/${SECONDARY_DBNAME}.${master}.db.1"
        ssh -n -o StrictHostKeyChecking=no -tt $master ${CMD} &> $LOGDIR/${SECONDARY_DBNAME}.${master}.db.1 &
        echo $! > ${TMPDIR}/${SECONDARY_DBNAME}.${master}.pid
    fi
    popd

    echo "Pause until it comes up"
    r=-1
    while [[ "$r" -ne "0" ]]; do
        $CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $master "select 1"
        r=$?
        sleep 1
    done

    echo "Refreshing all tunables"
    update_all_tunables
    delete_records
}

function exit_coordinator_before_commit
{
    echo "exit_coordinator_before_commit"
    typeset master=$(find_master)
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $master "put tunable debug_exit_coordinator_before_commit '1'"

    startms=$(timems)
    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    endms=$(timems)

    echo "sleeping for 30 seconds for sanity"
    sleep 30

    echo "Verify record is not there"

    x=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    [[ "$x" != "0" ]] && failexit "Uncommitted record in $DBNAME"

    x=$($CDB2SQL_EXE --tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "0" ]] && failexit "Uncommitted record in $DBNAME"

    x=$($CDB2SQL_EXE --tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "0" ]] && failexit "Uncommitted record in $DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "0" ]] && failexit "Uncommitted record in $DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "0" ]] && failexit "Uncommitted record in $DBNAME"

    echo "Restart $DBNAME on $master"
    pushd $DBDIR
    export LOGDIR=$TESTDIR/logs
    REP_ENV_VARS="${DBDIR}/replicant_env_vars"
    if [ $master == `hostname` ] ; then
        PARAMS="--no-global-lrl --lrl $DBDIR/${DBNAME}.lrl --pidfile ${TMPDIR}/${DBNAME}.${master}.pid"
        $COMDB2_EXE ${DBNAME} ${PARAMS} &> $LOGDIR/${DBNAME}.${master}.db.1 &
    else
        PARAMS="--no-global-lrl --lrl $DBDIR/${DBNAME}.lrl --pidfile ${TMPDIR}/${DBNAME}.${master}.pid"
        CMD="cd ${DBDIR}; source ${REP_ENV_VARS} ; $COMDB2_EXE ${DBNAME} ${PARAMS} 2>&1 | tee $TESTDIR/${DBNAME}.${master}.db.1"
        ssh -n -o StrictHostKeyChecking=no -tt $master ${CMD} &> $LOGDIR/${DBNAME}.${master}.db.1 &
        echo $! > ${TMPDIR}/${DBNAME}.${master}.pid
    fi
    popd

    echo "Pause until it comes up"
    r=-1
    while [[ "$r" -ne "0" ]]; do
        $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $master "select 1"
        r=$?
        sleep 1
    done

    echo "Refreshing all tunables"
    update_all_tunables
    delete_records_ignore_error
}

function exit_coordinator_after_commit
{
    echo "exit_coordinator_after_commit"
    typeset master=$(find_master)

    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $master "put tunable debug_exit_coordinator_after_commit '1'"

    startms=$(timems)
    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    endms=$(timems)

    echo "sleeping for 30 seconds for sanity"
    sleep 30

    echo "Verify record is there"

    x=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $DBNAME"

    x=$($CDB2SQL_EXE --tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $SECONDARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $TERTIARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $QUATERNARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "1" ]] && failexit "Record not in $QUINARY_DBNAME"

    echo "Restart $DBNAME on $master"
    pushd $DBDIR
    export LOGDIR=$TESTDIR/logs
    REP_ENV_VARS="${DBDIR}/replicant_env_vars"
    if [ $master == `hostname` ] ; then
        PARAMS="--no-global-lrl --lrl $DBDIR/${DBNAME}.lrl --pidfile ${TMPDIR}/${DBNAME}.${master}.pid"
        $COMDB2_EXE ${DBNAME} ${PARAMS} &> $LOGDIR/${DBNAME}.${master}.db.1 &
    else
        PARAMS="--no-global-lrl --lrl $DBDIR/${DBNAME}.lrl --pidfile ${TMPDIR}/${DBNAME}.${master}.pid"
        CMD="cd ${DBDIR}; source ${REP_ENV_VARS} ; $COMDB2_EXE ${DBNAME} ${PARAMS} 2>&1 | tee $TESTDIR/${DBNAME}.${master}.db.1"
        ssh -n -o StrictHostKeyChecking=no -tt $master ${CMD} &> $LOGDIR/${DBNAME}.${master}.db.1 &
        echo $! > ${TMPDIR}/${DBNAME}.${master}.pid
    fi
    popd

    echo "Pause until it comes up"
    r=-1
    while [[ "$r" -ne "0" ]]; do
        $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $master "select 1"
        r=$?
        sleep 1
    done

    echo "Refreshing all tunables"
    update_all_tunables
    delete_records_ignore_error
}

function run_test
{
    # bulk-test
    bulk_test

    # Last delete was expensive & early-acked, so the first insert will take longer 
    # Write a few records without bound latency (this slowness isn't 2pc related)
    insert_records_to_normalize

    # Single-record transactions
    basic_test

    # constraint-violations
    coordinator_constraint_violation
    participant_constraint_violation

    # participant recovery-tests
    exit_participant_after_prepare
    exit_participant_after_prepare_from_table

    # coordinator recovery-tests
    exit_coordinator_before_commit
    exit_coordinator_after_commit
}

function single_test
{
    typeset cnt=0
    while [[ "$cnt" -lt 3 ]]; do 
        let cnt=cnt+1
        echo "Test loop iteration $cnt"
        bulk_test 1
        insert_records_to_normalize
        basic_test 1
    done
}

rm ${DBNAME}.failexit >/dev/null 2>&1 
[[ -z "$CLUSTER" ]] && failexit "This test requires a 3-node cluster"

setup
single_test
#run_test
stop_all_databases

if [[ -f ${DBNAME}.failexit ]]; then
    echo "Testcase failed"
    exit -1
fi

echo "Success"
